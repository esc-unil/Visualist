# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Visualist
                                 A QGIS plugin
 Plugin for Crime Analysts
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-15
        copyright            : (C) 2019 by Quentin Rossy
        email                : quentin.rossy@unil.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Quentin Rossy'
__date__ = '2019-04-15'
__copyright__ = '(C) 2019 by Quentin Rossy'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import math, os
from tempfile import gettempdir

from shapely.geometry import LineString, MultiPoint
from shapely.ops import split

from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QVariant

from qgis.core import (QgsApplication,
                       QgsField,
                       QgsFeatureSink,
                       QgsFeature,
                       QgsGeometry,
                       QgsLineString,
                       QgsPoint,
                       QgsPointXY,
                       QgsRectangle,
                       QgsWkbTypes,
                       QgsProcessing,
                       QgsProcessingException,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterExtent,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDistance,
                       QgsProcessingParameterCrs,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterString,
                       QgsProcessingParameterBoolean,
                       QgsFields,
                       QgsProcessingUtils,
                       QgsFeatureRequest,
                       QgsSpatialIndex,
                       QgsCoordinateTransform,
                       QgsVectorLayer,
                       QgsProject)

from processing.algs.qgis.QgisAlgorithm import QgisAlgorithm
import processing

from .utils import renderers

def count_iterable(i):
    return sum(1 for e in i)

class PointsToLine(QgisAlgorithm):
    LINES = 'LINES'
    POINTS = 'POINTS'
    DIST = 'DIST'
    FIELD = 'FIELD'
    OUTPUT = 'OUTPUT'

    def icon(self):
        iconName = 'graduated.png'
        return QIcon(":/plugins/visualist/icons/" + iconName)

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Cartography'

    def __init__(self):
        super().__init__()

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterFeatureSource(self.LINES,
                                                    self.tr('Lines'), [QgsProcessing.TypeVectorLine]))

        self.addParameter(QgsProcessingParameterFeatureSource(self.POINTS,
                                                    self.tr('Points'), [QgsProcessing.TypeVectorPoint]))

        self.addParameter(QgsProcessingParameterNumber(self.DIST,
                                                    self.tr('Maximum distance to the line'),
                                                    defaultValue=100))

        self.addParameter(QgsProcessingParameterString(self.FIELD,
                                                    self.tr('Count field name'), defaultValue='NUMPOINTS'))
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT,
                                                    self.tr('Line Map'), QgsProcessing.TypeVectorLine))

    def name(self):
        return 'pointstoline'

    def displayName(self):
        return self.tr('Graduated Lines Map')


    def postProcessAlgorithm(self, context, feedback):
        """
        PostProcessing Tasks to define the Symbology
        """
        output = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
        r = renderers.MapRender(output)
        r.prop(self.field_name, type=renderers.LINE)

        return {self.OUTPUT: self.dest_id}


    def addFeature(self, geom, attrs, count = 0):
        output_feature = QgsFeature()
        output_feature.setGeometry(geom)
        attrs.append(count) #count
        output_feature.setAttributes(attrs)
        self.sink.addFeature(output_feature, QgsFeatureSink.FastInsert)

    def processAlgorithm(self, parameters, context, feedback):
        line_source = self.parameterAsSource(parameters, self.LINES, context)
        if line_source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.LINES))

        point_source = self.parameterAsSource(parameters, self.POINTS, context)
        if point_source is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.POINTS))

        distance = self.parameterAsDouble(parameters, self.DIST, context)

        field_name = self.parameterAsString(parameters, self.FIELD, context)
        self.field_name = field_name

        fields = line_source.fields()
        fields.append(QgsField(field_name, QVariant.LongLong))
        field_count_index = fields.lookupField(field_name)

        self.seg_id = 0

        (self.sink, self.dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                               fields, QgsWkbTypes.LineString, line_source.sourceCrs(), QgsFeatureSink.RegeneratePrimaryKey)
        if self.sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))

        segList = {}
        t = QgsCoordinateTransform(point_source.sourceCrs(), line_source.sourceCrs(), context.transformContext())
        request = QgsFeatureRequest().setFilterRect(t.transform(line_source.sourceExtent(), QgsCoordinateTransform.ReverseTransform))
        count = count_iterable(point_source.getFeatures(request))
        total = 100.0 / count if count else 0

        feedback.setProgressText(self.tr('Calculate the number points for each segment'))
        for current, point_feature in enumerate(point_source.getFeatures(request)):
            if feedback.isCanceled():
                break
            minDist = None
            minFeatId = None
            point = point_feature.geometry().asPoint()
            point = t.transform(point)
            pointBox = QgsRectangle(
                point.x()-distance,
                point.y()-distance,
                point.x()+distance,
                point.y()+distance
            )
            request = QgsFeatureRequest().setFilterRect(pointBox)
            for line_feature in line_source.getFeatures(request):
                # feedback.pushInfo('Line: {}'.format(line_feature))
                if feedback.isCanceled():
                    break
                geom = line_feature.geometry()
                dist = geom.closestSegmentWithContext(point) #closestVertex
                if minDist == None or dist[0] < minDist:
                    minDist = dist[0]
                    minFeatId = line_feature.id()
            if minFeatId is not None:
                if minFeatId in segList:
                    segList[minFeatId]["TOT"] += 1
                else:
                    segList[minFeatId] = {"TOT":1}
            feedback.setProgress(int(current * total))

        feedback.setProgressText(self.tr('Create the layer'))
        total = 100.0 / len(segList)
        current = 0
        for fid, values in segList.items():
            feat = QgsFeature()
            line_source.getFeatures(QgsFeatureRequest(fid)).nextFeature(feat)
            self.addFeature(feat.geometry(), feat.attributes(), values["TOT"])
            feedback.setProgress(int(current * total))
            current += 1

        return {self.OUTPUT: self.dest_id}
